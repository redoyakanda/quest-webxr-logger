<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebXR + Raw IMU Logger (Quest)</title>
  <style>
    body { font-family: system-ui; margin: 16px; }
    button { font-size: 18px; padding: 10px 14px; margin: 6px 8px 6px 0; }
    #status { white-space: pre-wrap; font-size: 14px; margin-top: 12px; }
    canvas { width: 1px; height: 1px; position: fixed; left: -10000px; top: -10000px; }
    .ok { color: #0a7; }
    .bad { color: #c22; }
    .muted { color: #666; }
  </style>
</head>
<body>
  <h2>WebXR + Raw IMU Logger (Quest-Compatible)</h2>
  <p class="muted">HTTPS required. Click Enter VR, then Start Logging, then Stop + Download.</p>

  <button id="enterVr">Enter VR</button>
  <button id="startLog" disabled>Start Logging</button>
  <button id="stopLog" disabled>Stop + Download</button>

  <div id="status">Status: idle</div>
  <canvas id="c"></canvas>

<script>
(() => {
  const statusEl = document.getElementById("status");
  const btnEnter = document.getElementById("enterVr");
  const btnStart = document.getElementById("startLog");
  const btnStop  = document.getElementById("stopLog");
  const canvas   = document.getElementById("c");

  let gl = null;
  let xrSession = null;
  let xrRefSpace = null;
  let isLogging = false;

  const poseRows = [];
  const imuRows  = [];
  const sensors  = [];

  function line(msg) {
    statusEl.textContent = msg + "\n" + statusEl.textContent;
  }
  function nowMs(){ return performance.now(); }

  function toCSV(headers, rows) {
    const esc = (v) => {
      const s = String(v ?? "");
      return (s.includes(",") || s.includes('"') || s.includes("\n")) ? `"${s.replaceAll('"','""')}"` : s;
    };
    return [headers.map(esc).join(","), ...rows.map(r => r.map(esc).join(","))].join("\n");
  }

  function download(filename, text) {
    const blob = new Blob([text], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  // ---------- Raw sensor attempts ----------
  function startGenericSensor(SensorCtor, name, fields) {
    try {
      const s = new SensorCtor({ frequency: 200 });
      s.addEventListener("reading", () => {
        if (!isLogging) return;
        const row = [nowMs(), name];
        for (const f of fields) row.push(s[f]);
        row.push(s.timestamp ?? "");
        imuRows.push(row);
      });
      s.addEventListener("error", e => line(`${name} error: ${e.error?.name || ""} ${e.error?.message || e.message || ""}`));
      s.start();
      sensors.push(s);
      line(`${name} started`);
      return true;
    } catch (e) {
      line(`${name} not available: ${e.name || ""} ${e.message || e}`);
      return false;
    }
  }

  async function startIMU() {
    let any = false;
    if ("Gyroscope" in window) any = startGenericSensor(Gyroscope, "Gyroscope", ["x","y","z"]) || any;
    if ("Accelerometer" in window) any = startGenericSensor(Accelerometer, "Accelerometer", ["x","y","z"]) || any;
    if ("LinearAccelerationSensor" in window) any = startGenericSensor(LinearAccelerationSensor, "LinearAcceleration", ["x","y","z"]) || any;

    // Fallbacks (often blocked in XR browsers)
    window.addEventListener("devicemotion", (e) => {
      if (!isLogging) return;
      const a = e.accelerationIncludingGravity || {};
      const r = e.rotationRate || {};
      imuRows.push([nowMs(),"DeviceMotion", a.x,a.y,a.z, r.alpha,r.beta,r.gamma, e.interval ?? ""]);
    }, { passive: true });

    window.addEventListener("deviceorientation", (e) => {
      if (!isLogging) return;
      imuRows.push([nowMs(),"DeviceOrientation", e.alpha,e.beta,e.gamma, e.absolute?1:0, "","",""]);
    }, { passive: true });

    line("DeviceMotion/DeviceOrientation listeners attached");
    if (!any) line("No Generic Sensor streams started (browser may block raw IMU).");
  }

  function stopIMU() {
    for (const s of sensors) { try { s.stop(); } catch {} }
    sensors.length = 0;
  }

  // ---------- WebXR render loop ----------
  function onXRFrame(t, frame) {
    const session = frame.session;
    session.requestAnimationFrame(onXRFrame);

    const pose = frame.getViewerPose(xrRefSpace);
    if (!pose) return;

    // Must bind the framebuffer for proper presentation
    const baseLayer = session.renderState.baseLayer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, baseLayer.framebuffer);

    // Minimal "clear" per view (enough to satisfy runtime)
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    if (isLogging) {
      const tr = pose.views[0].transform;
      const p = tr.position;
      const o = tr.orientation;
      poseRows.push([nowMs(), t, p.x,p.y,p.z, o.x,o.y,o.z,o.w]);
    }
  }

  async function enterVR() {
    if (!navigator.xr) throw new Error("navigator.xr not available");

    const supported = await navigator.xr.isSessionSupported("immersive-vr");
    if (!supported) throw new Error("immersive-vr not supported");

    // Create WebGL context
    gl = canvas.getContext("webgl", { xrCompatible: true });
    if (!gl) throw new Error("Failed to create WebGL context");

    xrSession = await navigator.xr.requestSession("immersive-vr", {
      optionalFeatures: ["local-floor", "bounded-floor"]
    });

    xrSession.addEventListener("end", () => {
      line("XR session ended");
      xrSession = null;
      xrRefSpace = null;
      btnEnter.disabled = false;
      btnStart.disabled = true;
      btnStop.disabled = true;
      stopIMU();
    });

    // Ensure GL is XR compatible and attach XRWebGLLayer
    await gl.makeXRCompatible();
    xrSession.updateRenderState({ baseLayer: new XRWebGLLayer(xrSession, gl) });

    xrRefSpace = await xrSession.requestReferenceSpace("local-floor");

    // Start loop
    xrSession.requestAnimationFrame(onXRFrame);

    line("Entered VR successfully");
    btnEnter.disabled = true;
    btnStart.disabled = false;

    // Start IMU attempts after user gesture + XR start
    await startIMU();
  }

  function startLogging() {
    poseRows.length = 0;
    imuRows.length = 0;
    isLogging = true;
    btnStart.disabled = true;
    btnStop.disabled = false;
    line("Logging ON");
  }

  function stopAndDownload() {
    isLogging = false;
    btnStart.disabled = false;
    btnStop.disabled = true;
    line("Logging OFF. Downloading...");

    download("webxr_pose.csv", toCSV(
      ["t_perf_ms","xr_raf_t","px","py","pz","qx","qy","qz","qw"],
      poseRows
    ));

    download("raw_imu.csv", toCSV(
      ["t_perf_ms","source","v1","v2","v3","v4","v5","v6","v7"],
      imuRows
    ));

    line(`Saved pose rows=${poseRows.length}, imu rows=${imuRows.length}`);
  }

  btnEnter.onclick = async () => {
    try { await enterVR(); }
    catch (e) { line("Enter VR failed: " + (e.message || e)); }
  };
  btnStart.onclick = startLogging;
  btnStop.onclick = stopAndDownload;

  line("Ready. Serve via HTTPS and click Enter VR.");
})();
</script>
</body>
</html>
