<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quest WebXR Pose Logger</title>
  <style>
    body { font-family: system-ui; margin: 16px; }
    button { font-size: 18px; padding: 12px 16px; margin-right: 8px; }
    #status { margin-top: 12px; white-space: pre-wrap; }
    canvas { width: 1px; height: 1px; position: fixed; left: -10000px; top: -10000px; }
  </style>
</head>
<body>
  <h2>WebXR Pose Logger (Quest 2)</h2>
  <p>Click start → move → stop → downloads a .txt (CSV).</p>

  <button id="startBtn">Enter VR + Start Recording</button>
  <button id="stopBtn" disabled>Stop + Download</button>

  <div id="status">Status: idle</div>

  <canvas id="c"></canvas>

<script>
let xrSession = null;
let xrRefSpace = null;

let gl = null;
let records = [];
let recording = false;

const statusEl = document.getElementById("status");
const startBtn = document.getElementById("startBtn");
const stopBtn  = document.getElementById("stopBtn");
const canvas   = document.getElementById("c");

function setStatus(s) { statusEl.textContent = "Status: " + s; }
function qToArr(q){ return [q.x, q.y, q.z, q.w]; }
function vToArr(v){ return [v.x, v.y, v.z]; }

async function start() {
  try {
    if (!navigator.xr) {
      setStatus("navigator.xr not available. Open in Meta Quest Browser on HTTPS.");
      return;
    }

    const supported = await navigator.xr.isSessionSupported("immersive-vr");
    if (!supported) {
      setStatus("immersive-vr not supported on this browser/device.");
      return;
    }

    // Create WebGL context and make it XR-compatible
    gl = canvas.getContext("webgl", { alpha: false, antialias: false, preserveDrawingBuffer: false });
    if (!gl) { setStatus("Failed to create WebGL context."); return; }

    xrSession = await navigator.xr.requestSession("immersive-vr", {
      requiredFeatures: ["local-floor"]
    });

    // Important for Quest: bind an XRWebGLLayer
    await gl.makeXRCompatible();
    xrSession.updateRenderState({ baseLayer: new XRWebGLLayer(xrSession, gl) });

    xrRefSpace = await xrSession.requestReferenceSpace("local-floor");

    records = [];
    recording = true;

    startBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus("recording... (waiting for XR frames)");

    xrSession.addEventListener("end", () => {
      recording = false;
      xrSession = null;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      setStatus("session ended");
    });

    xrSession.requestAnimationFrame(onXRFrame);
  } catch (e) {
    setStatus("Start failed: " + (e && e.message ? e.message : e));
  }
}

function onXRFrame(t, frame) {
  if (!xrSession) return;

  const layer = xrSession.renderState.baseLayer;
  const pose = frame.getViewerPose(xrRefSpace);

  // Minimal render (blank frame) so the session progresses
  gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  if (pose && recording) {
    const view = pose.views[0];
    const headPos = view.transform.position;
    const headOri = view.transform.orientation;

    // Controller poses (gripSpace)
    const ctrls = { left: null, right: null };
    for (const src of xrSession.inputSources) {
      if (!src.gripSpace) continue;
      const gp = frame.getPose(src.gripSpace, xrRefSpace);
      if (!gp) continue;
      const obj = {
        position: vToArr(gp.transform.position),
        orientation: qToArr(gp.transform.orientation)
      };
      if (src.handedness === "left") ctrls.left = obj;
      if (src.handedness === "right") ctrls.right = obj;
    }

    records.push({
      t_ms: t,
      head_p: vToArr(headPos),
      head_q: qToArr(headOri),
      left_p: ctrls.left ? ctrls.left.position : [NaN,NaN,NaN],
      left_q: ctrls.left ? ctrls.left.orientation : [NaN,NaN,NaN,NaN],
      right_p: ctrls.right ? ctrls.right.position : [NaN,NaN,NaN],
      right_q: ctrls.right ? ctrls.right.orientation : [NaN,NaN,NaN,NaN],
    });

    if (records.length % 120 === 0) setStatus(`recording... samples=${records.length}`);
  }

  xrSession.requestAnimationFrame(onXRFrame);
}

function stopAndDownload() {
  recording = false;
  stopBtn.disabled = true;
  startBtn.disabled = false;

  // CSV inside a .txt
  let out = "";
  out += "t_ms,head_px,head_py,head_pz,head_qx,head_qy,head_qz,head_qw,";
  out += "l_px,l_py,l_pz,l_qx,l_qy,l_qz,l_qw,";
  out += "r_px,r_py,r_pz,r_qx,r_qy,r_qz,r_qw\n";

  for (const r of records) {
    out += `${r.t_ms},${r.head_p.join(",")},${r.head_q.join(",")},`;
    out += `${r.left_p.join(",")},${r.left_q.join(",")},`;
    out += `${r.right_p.join(",")},${r.right_q.join(",")}\n`;
  }

  const blob = new Blob([out], { type: "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `quest_webxr_pose_${Date.now()}.txt`;
  a.click();
  URL.revokeObjectURL(url);

  setStatus(`stopped. downloaded ${records.length} samples (.txt).`);

  if (xrSession) xrSession.end();
}

startBtn.addEventListener("click", start);
stopBtn.addEventListener("click", stopAndDownload);
</script>
</body>
</html>
