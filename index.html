<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quest WebXR Head Motion Logger</title>
  <style>
    body { font-family: system-ui; margin: 16px; }
    button { font-size: 18px; padding: 12px 16px; margin-right: 8px; }
    #status { margin-top: 12px; white-space: pre-wrap; }
    canvas { width: 1px; height: 1px; position: fixed; left: -10000px; top: -10000px; }
  </style>
</head>
<body>
  <h2>WebXR Head Motion Logger (Quest 2)</h2>
  <p>Start → move naturally → Stop → downloads .txt (CSV).</p>

  <button id="startBtn">Enter VR + Start Recording</button>
  <button id="stopBtn" disabled>Stop + Download</button>

  <div id="status">Status: idle</div>
  <canvas id="c"></canvas>

<script>
let xrSession = null;
let xrRefSpace = null;
let gl = null;

let records = [];
let recording = false;

const statusEl = document.getElementById("status");
const startBtn = document.getElementById("startBtn");
const stopBtn  = document.getElementById("stopBtn");
const canvas   = document.getElementById("c");

function setStatus(s) { statusEl.textContent = "Status: " + s; }
function qToArr(q){ return [q.x, q.y, q.z, q.w]; }
function vToArr(v){ return [v.x, v.y, v.z]; }

async function start() {
  try {
    if (!navigator.xr) {
      setStatus("navigator.xr not available. Use Meta Quest Browser on HTTPS.");
      return;
    }

    const supported = await navigator.xr.isSessionSupported("immersive-vr");
    if (!supported) {
      setStatus("immersive-vr not supported on this browser/device.");
      return;
    }

    gl = canvas.getContext("webgl", { alpha:false, antialias:false });
    if (!gl) { setStatus("Failed to create WebGL context."); return; }

    xrSession = await navigator.xr.requestSession("immersive-vr", {
      requiredFeatures: ["local-floor"]
    });

    // Quest Browser often needs an XRWebGLLayer and a render loop to avoid “3 dots”.
    await gl.makeXRCompatible();
    xrSession.updateRenderState({ baseLayer: new XRWebGLLayer(xrSession, gl) });

    xrRefSpace = await xrSession.requestReferenceSpace("local-floor");

    records = [];
    recording = true;

    startBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus("recording...");

    xrSession.addEventListener("end", () => {
      recording = false;
      xrSession = null;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      setStatus("session ended");
    });

    xrSession.requestAnimationFrame(onXRFrame);
  } catch (e) {
    setStatus("Start failed: " + (e && e.message ? e.message : e));
  }
}

function onXRFrame(t, frame) {
  if (!xrSession) return;

  // Render a blank frame so the immersive session progresses.
  const layer = xrSession.renderState.baseLayer;
  gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  if (recording) {
    const pose = frame.getViewerPose(xrRefSpace);
    if (pose) {
      const view = pose.views[0];
      const p = vToArr(view.transform.position);
      const q = qToArr(view.transform.orientation);

      // t is DOMHighResTimeStamp in ms from the same time origin as performance.now()
      records.push({
        t_ms: t,
        t_sec: t / 1000.0,
        px: p[0], py: p[1], pz: p[2],
        qx: q[0], qy: q[1], qz: q[2], qw: q[3],
      });

      if (records.length % 120 === 0) setStatus(`recording... samples=${records.length}`);
    }
  }

  xrSession.requestAnimationFrame(onXRFrame);
}

function stopAndDownload() {
  recording = false;
  stopBtn.disabled = true;
  startBtn.disabled = false;

  // CSV inside a .txt file
  let out = "t_ms,t_sec,px,py,pz,qx,qy,qz,qw\n";
  for (const r of records) {
    out += `${r.t_ms},${r.t_sec},${r.px},${r.py},${r.pz},${r.qx},${r.qy},${r.qz},${r.qw}\n`;
  }

  const blob = new Blob([out], { type: "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `quest_webxr_headpose_${Date.now()}.txt`;
  a.click();
  URL.revokeObjectURL(url);

  setStatus(`stopped. downloaded ${records.length} samples (.txt).`);

  if (xrSession) xrSession.end();
}

startBtn.addEventListener("click", start);
stopBtn.addEventListener("click", stopAndDownload);
</script>
</body>
</html>
